{#- This banner is for the the resulting file -#}
#####################################################################
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN #
#####################################################################

# Color code lookups
ERROR='\033[0;31m'
WARNING='\033[0;33m'
INFO='\033[0m'
DEFAULT='\033[0m'


function _feedback() {
  # Use the provided color code label
  color="${1}"
  case "${1}" in
    ERROR)
      # echo to stderr with the appropriate coloring, reset the color back to
      # the default when done
      >&2 echo -e "${!color}${1}:  ${2}${DEFAULT}" ;;
    WARNING)
      # echo to stderr with the appropriate coloring, reset the color back to
      # the default when done
      >&2 echo -e "${!color}${1}:  ${2}${DEFAULT}" ;;
    *)
      # echo to stdout with the appropriate coloring, reset the color back to
      # the default when done
      echo -e "${!color}${1}:  ${2}${DEFAULT}" ;;
  esac
}


function process_command_exit_status() {
  # Store the provided exit status to return it at the end
  exit_status="${1}"
  command="${2}"
  description="${3}"

  if [[ "${exit_status}" != 0 ]]; then
    _feedback ERROR "Failed ${command} ${description}"
  else
    _feedback INFO "Passed ${command} ${description}"
  fi

  # If the shell is not interactive ("i" is not in the $- variable), skip
  # multiple runs of the provided command by timestamping the touch file
  if [[ ! "${-}" =~ .*i.* ]]; then
    # If there are any spaces in the provided command, replace them with _s
    date +%s > "/${command// /_}_complete"
  fi

  return "${exit_status}"
}


{# Loop through each provided command to be wrapped and make a single wrapper function for it -#}
{% for command in commands -%}
{%- if commands[command]["security"] is defined -%}
function {{ command }}() {
  # Methods to skip **all** security tools for {{ command }}
  DISABLE_SECURITY="${DISABLE_SECURITY:-false}"

  if [[ "${1}" == "{{ commands[command]["version_argument"] }}" ]]; then
    _feedback INFO "Detected version check, skipping security checks for {{ command }}"
    command "${FUNCNAME[0]}" "$@"
    return $?
  elif [[ "${1}" == "--disable-security" ]]; then
    _feedback WARNING "Skipping all security checks for {{ command }} due to the --disable-security argument"
    shift
    command "${FUNCNAME[0]}" "$@"
    return $?
  elif [[ "${DISABLE_SECURITY,,}" == "true" ]]; then
    _feedback WARNING "Skipping all security checks for {{ command }} due to the DISABLE_SECURITY environment variable value"
    command "${FUNCNAME[0]}" "$@"
    return $?
  else
    ## Validate the input prior to running security tooling
    {%- for validation in commands[command]["validation"] %}
    # If the initialization was already run successfully in an non-interactive
    # shell, don't run it again
    if [[ -r "/{{ validation.command | replace(" ", "_") }}_complete" ]]; then
      _feedback INFO "Skipping \`{{ validation.command }}\` because it was already run on $(date -d @"$(cat /{{ validation.command | replace(" ", "_") }}_complete)")"
    else
      command {{ validation.command }} &>/{{ validation.command | replace(" ", "_") }}_output
      process_command_exit_status "${?}" "{{ validation.command }}" "{{ validation.description }}"
      return=${?}
      if [[ ${return:-1} != 0 ]]; then
        cat /{{ validation.command | replace(" ", "_") }}_output
        return "${return}"
      fi
    fi
    {%- endfor %}
  fi

  ## Setup the per-tool security integrations
{#- For each command being wrapped, loop through each security tool and make tool-specific skips via env var/argument #}
  {%- for tool in commands[command]["security"] %}
  {{ tool }}_upper=$(echo "{{ tool }}" | tr '[:lower:]' '[:upper:]')
  {{ tool }}_argument="--skip-{{ tool }}"
  {# In order for us to use ${variable} in bash directly around a jinja2 variable it needs to be escaped -#}
  {{ tool }}_env_var="SKIP_{{ '${' }}{{ tool }}_upper}"
  declare "SKIP_{{ '${' }}{{ tool }}_upper}={{ '${' }}!{{ tool }}_env_var:-false}"

  ## Methods to skip {{ tool }}
  # If the "skip" argument was provided, skip the security scan
  if [[ "${1}" == "{{ '${' }}{{ tool }}_argument}" ]]; then
    _feedback WARNING "Skipping {{ tool }} due to {{ '${' }}{{ tool }}_argument}"
    shift
  # If the "skip" environment variable was set to true, skip the security scan
  elif [[ "${!{{ tool }}_env_var,,}" == "true" ]]; then
    _feedback WARNING "Skipping {{ tool }} due to the {{ '${' }}{{ tool }}_env_var} environment variable value"
  # If the security scan was already run successfully in an non-interactive
  # shell, don't run it again
  elif [[ -r "/{{ tool }}_complete" ]]; then
    _feedback INFO "Skipping {{ tool }} because it was already run on $(date -d @"$(cat /{{ tool }}_complete)")"
  # Otherwise, run the security tool
  else
    {{ commands[command]["security"][tool].command }} &>/{{ tool }}_output
    process_command_exit_status "${?}" "{{ tool }}" "{{ commands[command]["security"][tool].description }}"
    return=${?}
    if [[ ${return:-1} != 0 ]]; then
      cat /{{ tool }}_output
      return ${return}
    fi
  fi
  {%- endfor %}

  # Run the command per a PATH lookup, after any easy_infra specific arguments are removed
  command "${FUNCNAME[0]}" "$@"
}

{% endif -%}
{%- endfor -%}
