{#- This banner is for the the resulting file -#}
#####################################################################
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN #
#####################################################################

# Color code lookups
ERROR='\033[0;31m'
WARNING='\033[0;33m'
DEBUGGING='\033[0;36m'
INFORMATIONAL='\033[0m'
DEFAULT='\033[0m'


function _feedback() {
  # Use the provided color code label
  color="${1}"
  case "${1}" in
    ERROR)
      # echo to stderr with the appropriate coloring
      >&2 echo -e "${!color}${1}:  ${2}${DEFAULT}" ;;
    WARNING)
      # echo to stderr with the appropriate coloring
      >&2 echo -e "${!color}${1}:  ${2}${DEFAULT}" ;;
    *)
      # echo to stdout with the appropriate coloring
      echo -e "${!color}${1}:  ${2}${DEFAULT}" ;;
  esac
}


function process_command_exit_status() {
  # Store the provided exit status to return it at the end
  exit_status="${1}"
  command="${2}"
  description="${3}"

  if [[ "${exit_status}" != 0 ]]; then
    _feedback ERROR "Failed ${command} ${description}"
  else
    _feedback INFORMATIONAL "Passed ${command} ${description}"
  fi

  # If the shell is not interactive ("i" is not in the $- variable), skip
  # multiple runs of the provided command by timestamping the touch file
  if [[ ! "${-}" =~ .*i.* ]]; then
    # If there are any spaces in the provided command, replace them with _s
    date +%s > "/tmp/${command// /_}_complete"
  fi

  return "${exit_status}"
}

{# Macro to be used by the loops below #}
{% macro function(function, tools, allow_filter, version_argument, validations, security_tools, customizations) %}
function {{ function }}() {
  arguments=("${@}")
  easy_infra_{{ function | replace("-", "_") }}_tools=({% for tool in tools %}{{ tool | replace("-", "_") }}{% if not loop.last %} {% endif %}{% endfor %})

  # If an argument was provided which adjusts the easy_infra runtime, set a
  # related variable and remove that argument from the arguments array
  for i in "${!arguments[@]}"; do
    if [[ "${arguments[i],,}" == "--disable-security" ]]; then
      unset 'arguments[i]'
      security_skipped="argument"
    fi

    for tool in "${easy_infra_{{ function | replace("-", "_") }}_tools[@]}"; do
      if [[ "${arguments[i],,}" == "--skip-${tool}" ]]; then
        unset 'arguments[i]'
        declare "${tool}_skipped=argument"
      fi
    done
  done

{% if allow_filter is defined %}
  # Apply the allow filters after easy_infra specific arguments have been
  # removed
  for i in "${!arguments[@]}"; do
{%- for filter in allow_filter %}
    if [[ "${i}" == "{{ filter['position'] }}" && "${arguments[i]}" == "{{ filter['match'] }}" ]]; then
      hit="true"
    fi
{%- endfor %}

    if [[ "${hit:-false}" == "false" ]]; then
      # Run the command and return
      command "${FUNCNAME[0]}" "${arguments[@]}"
      return $?
    fi
  done
{%- endif %}

  # Methods to skip **all** security tools for {{ function }}
  DISABLE_SECURITY="${DISABLE_SECURITY:-false}"

  if [[ "${1}" == "{{ version_argument }}" ]]; then
    _feedback INFORMATIONAL "Detected version check, skipping security checks for {{ function }}"
    # Allow piping of the version command into other commands
    command "${FUNCNAME[0]}" "${arguments[@]}"
    return $?
  elif [[ "${security_skipped:-false}" == "argument" ]]; then
    _feedback WARNING "Skipping all security checks for {{ function }} due to the --disable-security argument"
    unset 'security_skipped'
    command "${FUNCNAME[0]}" "${arguments[@]}"
    return $?
  elif [[ "${DISABLE_SECURITY,,}" == "true" ]]; then
    _feedback WARNING "Skipping all security checks for {{ function }} due to the DISABLE_SECURITY environment variable value"
    command "${FUNCNAME[0]}" "${arguments[@]}"
    return $?
{%- if validations is defined %}
  else
    ## Validate the input prior to running security tooling
    {%- for validation in validations %}
    # If the initialization was already run successfully in an non-interactive
    # shell, don't run it again
    if [[ -r "/tmp/{{ validation.command | replace(" ", "_") }}_complete" ]]; then
      _feedback INFORMATIONAL "Skipping \`{{ validation.command }}\` because it was already run on $(date -d @"$(cat /tmp/{{ validation.command | replace(" ", "_") }}_complete)")"
    else
      command {{ validation.command }} &>/tmp/{{ validation.command | replace(" ", "_") }}_output
      process_command_exit_status "${?}" "{{ validation.command }}" "{{ validation.description }}"
      return=${?}
      if [[ ${return:-1} != 0 ]]; then
        cat /tmp/{{ validation.command | replace(" ", "_") }}_output
        if [[ "${LEARNING_MODE,,}" != "true" ]]; then
          return "${return}"
        elif [[ "${LOG_LEVEL,,}" == "debug" ]]; then
          _feedback DEBUGGING "Learning mode enabled, not returning {{ validation.command }}'s exit code of ${return}"
        fi
      fi
    fi
    {%- endfor -%}
{%- endif %}
  fi

  ## Setup the per-tool security integrations
  {#- For each command being wrapped, loop through each security tool and apply tool-specific skips based on env vars/arguments #}
  {%- for security_tool in security_tools %}
  {{ security_tool | replace("-", "_") }}_skip_argument="--skip-{{ security_tool | replace("-", "_") }}"
  {{ security_tool | replace("-", "_") }}_upper=$(echo "{{ security_tool | replace("-", "_") }}" | tr '[:lower:]' '[:upper:]')
  {{ security_tool | replace("-", "_") }}_skip_env_var="SKIP_{{ '${' }}{{ security_tool | replace("-", "_") }}_upper}"
  declare "SKIP_{{ '${' }}{{ security_tool | replace("-", "_") }}_upper}={{ '${' }}!{{ security_tool | replace("-", "_") }}_skip_env_var:-false}"

  ## Methods to skip {{ security_tool | replace("-", "_") }}
  if [[ "{{ '${' }}{{ security_tool | replace("-", "_") }}_skipped:-false}" == "argument" ]]; then
    _feedback WARNING "Skipping {{ security_tool | replace("-", "_") }} due to {{ '${' }}{{ security_tool | replace("-", "_") }}_skip_argument}"
    unset '{{ security_tool | replace("-", "_") }}_skipped'
  # If the "skip" environment variable was set to true, skip the security scan
  elif [[ "${!{{ security_tool | replace("-", "_") }}_skip_env_var,,}" == "true" ]]; then
    _feedback WARNING "Skipping {{ security_tool | replace("-", "_") }} due to the {{ '${' }}{{ security_tool | replace("-", "_") }}_skip_env_var} environment variable value"
  # If the security scan was already run successfully in an non-interactive
  # shell, don't run it again
  elif [[ -r "/tmp/{{ security_tool | replace("-", "_") }}_complete" ]]; then
    _feedback INFORMATIONAL "Skipping {{ security_tool | replace("-", "_") }} because it was already run on $(date -d @"$(cat /tmp/{{ security_tool | replace("-", "_") }}_complete)")"
  # Otherwise, attempt to run the security tool
  else
    if [[ -x $(which {{ security_tool }}) ]]; then
      security_tool_command='{{ security_tools[security_tool].command }}'
      {%- if security_tools[security_tool]["customizations"] is defined %}
      {%- for env_var, argument in security_tools[security_tool]["customizations"].items() %}
      if [[ -v {{ env_var }} ]]; then
        security_tool_command+=' {{ argument }} "{{ '${' }}{{ env_var }}{{ '}' }}"'
      fi
      {%- endfor %}
      {%- endif %}
      eval '${security_tool_command} &>/tmp/{{ security_tool | replace("-", "_") }}_output'
      process_command_exit_status "${?}" "{{ security_tool | replace("-", "_") }}" "{{ security_tools[security_tool].description }}"
      return=${?}
      if [[ ${return:-1} != 0 ]]; then
        cat /tmp/{{ security_tool | replace("-", "_") }}_output
        if [[ "${LEARNING_MODE,,}" != "true" ]]; then
          return ${return}
        elif [[ "${LOG_LEVEL,,}" == "debug" ]]; then
          _feedback DEBUGGING "Learning mode enabled, not returning {{ security_tool }}'s exit code of ${return}"
        fi
      fi
    elif [[ "${LOG_LEVEL,,}" == "debug" ]]; then
      _feedback DEBUGGING "Did not run {{ security_tool }} because it was either not in the path or is not executable"
    fi
  fi
  {%- endfor %}

  # Run the command per a PATH lookup, after any easy_infra specific arguments
  # are removed
  command "${FUNCNAME[0]}" "${arguments[@]}"
}
{% endmacro %}

{# Loop through each provided command (or aliases, if they are set) to be wrapped and make a single wrapper function for it -#}
{% for command in commands if commands[command]["security"] -%}
{% for alias in commands[command]["aliases"] -%}
{{ function(alias, commands[command]["security"], commands[command]["allow_filter"], commands[command]["version_argument"], commands[command]["validation"], commands[command]["security"]) }}
{% else %}
{{ function(command, commands[command]["security"], commands[command]["allow_filter"], commands[command]["version_argument"], commands[command]["validation"], commands[command]["security"]) }}
{% endfor %}
{%- endfor -%}

