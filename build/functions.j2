{#- This banner is for the the resulting file -#}
#####################################################################
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN #
#####################################################################

# All private functions (start with _) come from here
source /usr/local/bin/common.sh


function run_command() {
  if [[ "$#" -lt 1 ]]; then
    echo "Improper use of the easy_infra run_command function; $# arguments provided when at least 1 was expected"
    return 230
  fi

  function_name="${1}"
  shift
  function_arguments=("${@}")

  if [[ "${function_name}" =~ ^scan_.* ]]; then
    # Special case to handle our "scan_" functions
    return
  fi

  command "${function_name}" "${function_arguments[@]}"
}

function process_dir_exit_codes() {
  exit_code_type="${1}"
  dir_exit_codes="${2}"

  ## Process the exit codes from each directory
  for dir in "${!dir_exit_codes[@]}"; do
    if [[ "${dir_exit_codes[${dir}]}" -gt 0 ]]; then
      feedback_label="ERROR"
      something_failed="true"
      failure_exit_code="${dir_exit_codes[${dir}]}"
    else
      feedback_label="DEBUG"
    fi
    exit_code="${dir_exit_codes[${dir}]}"
    _feedback "${feedback_label}" "Running the ${exit_code_type} in ${dir} resulted in an exit code of ${exit_code}"
  done

  return failure_exit_code
}

function run_hooks() {
  local function_name="${1}"
  local function_subcommands="${2}"
  local hook_type="${3}"
  local hooks="${4}"
  local message

  if [[ "${DISABLE_HOOKS:-false}" == "true" ]]; then
    message="DISABLE_HOOKS is set to ${DISABLE_HOOKS}; skipping the ${hook_type} hooks for the ${function_name}${function_subcommands} {{ filter['match'] }}{% endfor %} command..."
    _feedback WARNING "${message}"
    _log "easy_infra.stdouterr" info unknown "{{ function }}" "${dir}" string "${message}"
  else
    for hook in ${hooks[@]}; do
      bash "${hook}"
      return=$?
      if [[ "${return:-1}" != 0 ]]; then
        if [[ "${LEARNING_MODE,,}" == "true" ]]; then
          message="${hook} exited non-zero but learning mode was ${learning_mode} so suppressing the failure"
          _log "easy_infra.stdouterr" allowed failure "easy_infra" "${dir}" string "${message}"
          _feedback DEBUG "${message}"
        else
          popd > /dev/null
          if [[ "${FAIL_FAST:-false}" == "true" ]]; then
            message="${hook} exited non-zero and fail_fast is set to ${FAIL_FAST}; returning the exit code of ${return}"
            _log "easy_infra.stdouterr" denied failure "easy_infra" "${dir}" string "${message}"
            _feedback DEBUG "${message}"
            return "${return}"
          else
            message="${hook} exited non-zero and fail_fast is set to ${FAIL_FAST:-null or unset}; capturing the exit code of ${return}"
            _log "easy_infra.stdouterr" denied failure "easy_infra" "${dir}" string "${message}"
            _feedback DEBUG "${messsage}"
            declare "${hook_type}_hook_dir_exit_codes"["${dir}"]="${return}"
            continue
          fi
        fi
      else
        # Intentionally no _log or _feedback when the return code is 0; we expect those messages are in the hook themselves
        :
      fi
    done
  fi
}

function run_tool_if_disable_security_is_set() {
  local function_name="${1}"
  local function_subcommands="${2}"

  if [[ "${security_skipped:-false}" == "argument" ]]; then
    message="Skipping all security checks for ${function_name}${function_subcommands} due to the --disable-security argument"
    _feedback WARNING "${message}"
    _log "easy_infra.stdouterr" info unknown "${function_name}" "${dir}" string "${message}"
    unset 'security_skipped'
    run_command "${function_name}" "${arguments[@]}"
    return=$?
    popd > /dev/null
    if [[ "${return:-1}" != 0 ]]; then
      if [[ "${FAIL_FAST:-false}" == "true" ]]; then
        _feedback INFO "FAIL_FAST is set to ${FAIL_FAST}; returning the exit code of ${return} immediately"
        return "${return}"
      else
        command_dir_exit_codes["${dir}"]="${return}"
        return
      fi
    fi
    return
  elif [[ "${DISABLE_SECURITY,,}" == "true" ]]; then
    message="Skipping all security checks for ${function_name}${function_subcommands} due to the DISABLE_SECURITY environment variable value"
    _feedback WARNING "${message}"
    _log "easy_infra.stdouterr" info unknown "${function_name}" "${dir}" string "${message}"
    run_command "${function_name}" "${arguments[@]}"
    return=$?
    popd > /dev/null
    if [[ "${return:-1}" != 0 ]]; then
      if [[ "${FAIL_FAST:-false}" == "true" ]]; then
        _feedback INFO "FAIL_FAST is set to ${FAIL_FAST}; returning the exit code of ${return} immediately"
        return "${return}"
      else
        command_dir_exit_codes["${dir}"]="${return}"
        return
      fi
    fi
    return
  fi
}

function should_we_run_scans() {
  local dirs_to_hash="${1}"

  hash="$(sha256sum <(find ${dirs_to_hash[@]} -type f -exec sha256sum {} \; | sort) | awk '{print $1}')"
  sanitized_cwd="${dir//\//_}"
  hashfile="/tmp/{{ function }}.${sanitized_cwd}.hash"
  previous_hash='empty'
  if [[ -r "${hashfile}" ]]; then
    previous_hash="$(tail -1 "${hashfile}")"
  fi
  if [[ -r "${hashfile}" && -n ${hash} && ${hash} == "${previous_hash}" ]]; then
    _feedback DEBUG "Setting run_scans to ${run_scans} because the hashfile already exists and the current hash matches the previous hash"
    return "false"
  elif [[ -r "${hashfile}" ]]; then
    _feedback INFO "The files at ${dirs_to_hash[*]} were changed from ${previous_hash} to ${hash}; reactivating scans..."
    echo "${hash}" >> "${hashfile}"
    return "true"
  elif [[ -z ${hash} ]]; then
    _feedback ERROR "Unable to obtain the hash of the files at ${dirs_to_hash[*]}; this should never happen"
    exit 1
  else
    _feedback DEBUG "Creating ${hashfile} with the contents ${hash} due to the files at ${dirs_to_hash[*]}"
    # This creates the hashfile
    echo "${hash}" >> "${hashfile}"
    return "true"
  fi
}

function should_we_run_security_tool() {
    local security_tool_skipped="${1}"
    local security_tool="${2}"
    local security_tool_sanitized="sed 's/-/_/g' <<< ${security_tool}"
    local security_tool_sanitized_lower="${security_tool_sanitized,,}"
    local security_tool_sanitized_upper="${security_tool_sanitized^^}"
    local security_tool_skip_argument="--skip-${security_tool_sanitized_lower}"
    local security_tool_skip_env_var="SKIP_${security_tool_sanitized_upper}"
    local message

    ## Methods to skip the provided security tool
    if [[ "${security_tool_skipped}" == "argument" ]]; then
      message="Skipping ${security_tool} due to ${security_tool_skip_argument}"
      _feedback WARNING "${message}"
      _log "easy_infra.stdouterr" info unknown "${security_tool}-skipped" "${dir}" string "${message}"
      unset '{{ security_tool | replace("-", "_") }}_skipped'
      return "false"
    # If the "skip" environment variable was set to true, skip the security scan
    elif [[ "${!{{ security_tool | replace("-", "_") }}_skip_env_var,,}" == "true" ]]; then
      message="Skipping {{ security_tool }} due to the {{ '${' }}{{ security_tool | replace("-", "_") }}_skip_env_var} environment variable value"
      _feedback WARNING "${message}"
      _log "easy_infra.stdouterr" info unknown "{{ security_tool }}-skipped" "${dir}" string "${message}"
      return "false"
    # If the security scan was already run and the filesystem hasn't changed since then, don't run it again
    elif [[ ${run_scans:-true} == "false" && -r "/tmp/{{ security_tool | replace("-", "_") }}_complete" ]]; then
      local last_run_timestamp="$(date -d @"$(cat /tmp/${security_tool_sanitized_lower}_complete)")"
      message="Skipping ${security_tool} because it was already run on ${last_run_timestamp} and the filesystem has not changed since then"
      _feedback INFO "${message}"
      _log "easy_infra.stdouterr" info unknown "{{ security_tool }}-skipped" "${dir}" string "${message}"
      return "false"
    fi

    ## Otherwise, we should run the security tool
    return "true"
}

function process_command_exit_status() {
  # Store the provided exit status to return it at the end
  exit_status="${1}"
  command="${2}"
  description="${3}"

  if [[ "${exit_status}" != 0 ]]; then
    _feedback ERROR "Failed ${command} ${description}"
  else
    _feedback INFO "Passed ${command} ${description}"
  fi

  # Catalog when the last run was completed
  date +%s > "/tmp/${command// /_}_complete"

  return "${exit_status}"
}

{# Macro to be used by the loops below #}
{%- macro function(function, package=function, scan=false) %}

{%- set file_extensions = packages[package]["file_extensions"] -%}
{%- set security_tools = packages[package]["security"] -%}
{%- set allow_filter = packages[package]["allow_filter"] -%}
{%- set version_argument = packages[package]["version_argument"] -%}
{%- set validations = packages[package]["validation"] -%}
{%- set monitor = packages[package]["monitor"] -%}
# TODO: Is this working?
{%- set function = "scan_" ~ function if scan else function -%}

function {{ function }}() {
  _feedback DEBUG "Entering the ${FUNCNAME[0]} function..."
  arguments=("${@}")
  easy_infra_{{ function | replace("-", "_") }}_security_tools=({% for security_tool in security_tools %}{{ security_tool | replace("-", "_") }}{% if not loop.last %} {% endif %}{% endfor %})
  function_subcommands"{% for filter in allow_filter if allow_filter is defined %} {{ filter['match'] }}{% endfor %}"

  # If an argument was provided which adjusts the easy_infra runtime, set a related variable and remove that argument from the arguments array
  for i in "${!arguments[@]}"; do
    if [[ "${arguments[i],,}" == "--disable-security" ]]; then
      unset 'arguments[i]'
      security_skipped="argument"
    fi

    for security_tool in "${easy_infra_{{ function | replace("-", "_") }}_security_tools[@]}"; do
      if [[ "${arguments[i],,}" == "--skip-${security_tool}" ]]; then
        unset 'arguments[i]'
        declare "${security_tool}_skipped=argument"
      fi
    done
  done

{% if scan %}
  if [[ "${1}" == "version" ]]; then
    _feedback INFO "Detected version check, skipping security checks for scan_{{ function }}"
    echo "{{ function }} is using the following security tools:"
    for security_tool in "${easy_infra_{{ function | replace("-", "_") }}_security_tools[@]}"; do
      security_tool_version_variable="${security_tool^^}_VERSION"
      echo "${security_tool} version ${!security_tool_version_variable}"
    done
    return
{%- else %}
  if [[ "${1}" == "{{ version_argument }}" ]]; then
    _feedback INFO "Detected version check, skipping security checks for {{ function }}${function_subcommands}"
    # Allow piping of the version command into other commands
    run_command "${FUNCNAME[0]}" "${arguments[@]}"
    return $?
{%- endif %}
  fi

{% if allow_filter is defined %}
  # Apply the allow filters after easy_infra specific arguments have been removed
  for i in "${!arguments[@]}"; do
{%- for filter in allow_filter %}
    if [[ "${i}" == "{{ filter['position'] }}" && "${arguments[i]}" == "{{ filter['match'] }}" ]]; then
      hit="true"
    fi
{%- endfor %}

    if [[ "${hit:-false}" == "false" ]]; then
      # Run the command and return
      run_command "${FUNCNAME[0]}" "${arguments[@]}"
      return $?
    fi
  done
{%- endif %}

  easy_infra_{{ function | replace("-", "_") }}_pre_hooks=()
  if [[ "${DISABLE_HOOKS:-false}" != "true" ]]; then
    # Dynamically register hooks
    for file in /opt/hooks/bin/*.sh; do
      hook_command=$(awk -F\: '/register_hook/ { gsub(/ /,""); print $2 }' "${file}")
      hook_type=$(awk -F\: '/register_hook/ { print $3 }' "${file}")
      if [[ "${hook_command}" == "{{ function }}" ]]; then
        if [[ "${hook_type:-}" == "pre" ]]; then
          _feedback DEBUG "Registering ${file} to the ${FUNCNAME[0]} pre hooks"
          easy_infra_{{ function | replace("-", "_") }}_pre_hooks+=("${file}")
        else
          _feedback DEBUG "Hook detected with no hook type specified; Registering ${file} to the ${FUNCNAME[0]} pre hooks"
          easy_infra_{{ function | replace("-", "_") }}_pre_hooks+=("${file}")
        fi
      fi
    done
  fi

  # Adds the detected git toplevel as a safe directory to prevent errors when generating git context for logs.
  current_dir=$(pwd -P)
  export GIT_CONFIG_COUNT=1
  _feedback DEBUG "Set GIT_CONFIG_COUNT to ${GIT_CONFIG_COUNT}"
  export GIT_CONFIG_KEY_0="safe.directory"
  _feedback DEBUG "Set GIT_CONFIG_KEY_0 to ${GIT_CONFIG_KEY_0}"
  GIT_CONFIG_VALUE_0="$(git rev-parse --show-toplevel 2>/dev/null || echo ${current_dir})"
  export GIT_CONFIG_VALUE_0
  _feedback DEBUG "Set GIT_CONFIG_VALUE_0 to ${GIT_CONFIG_VALUE_0}"

  # Methods to skip **all** security tools for {{ function }}{% for filter in allow_filter if allow_filter is defined %} {{ filter['match'] }}{% endfor %}
  DISABLE_SECURITY="${DISABLE_SECURITY:-false}"
  dirs=()
  _feedback DEBUG "AUTODETECT is ${AUTODETECT:-not set}"
  if [[ "${AUTODETECT:-false}" == "true" ]]; then
{%- if file_extensions is defined %}
{%- for file_extension in file_extensions %}
    files=$(find . -iname "*.{{ file_extension }}" -type f)
    if [[ "${files}" ]]; then
      _feedback DEBUG "Adding to the dirs loop due to detecting files with the {{ file_extension }} extension: ${files}"
      dirs+=($(for file in ${files}; do dirname ${file}; done | sort -u | xargs readlink --canonicalize))
    fi
{%- endfor %}
{%- else %}
    dir=$(pwd -P)
    _feedback WARNING "AUTODETECT enabled, but {{ function }}${function_subcommands} does not have any file extensions configured to search for; falling back to running in ${dir}"
    _log "easy_infra.stdouterr" info unknown "{{ function }}" "${dir}" string "Failed to properly autodetect the directories to scan when running a {{ function }}${function_subcommands} command"
    dirs+=("${dir}")
{%- endif %}
  else
    dirs+=($(pwd -P))
  fi

  declare -A pre_hook_dir_exit_codes
  declare -A command_dir_exit_codes

  if [ "{{ '${' }}#dirs[@]}" -eq 0 ]; then
    _feedback WARNING "The function ${FUNCNAME[0]} has no directories to iterate through; did you run ${FUNCNAME[0]} with AUTODETECT=true but with no matching files in any subdirectories?"
  else
    _feedback DEBUG "The final dirs array is ${dirs[*]:-empty}"
  fi

  for dir in "${dirs[@]}"; do
    _feedback INFO "Changing into the ${dir} directory..."
    pushd "${dir}" > /dev/null

    # Keep the git config value aligned with the current directory
    GIT_CONFIG_VALUE_0="$(git rev-parse --show-toplevel 2>/dev/null || echo ${current_dir})"

    # Export variables to be used in the hooks
    export dir

    # Run the registered "pre" hooks; this modifies dir_exit_codes
    pre_hooks_return="$(run_hooks "{{ function }}" "${function_subcommands}" "pre" "${easy_infra_{{ function | replace("-", "_") }}_pre_hooks[@]}")"

    if [[ "${pre_hooks_return}" -gt 0 ]]; then
      # disable security, learning mode, and fail fast logic is in the upstream function; if it returns non-zero we should return with that immediately
      return "${pre_hooks_return}"
    fi

    # Run the tools if disable security is set; this modifies dir_exit_codes
    tool_return="$(run_tool_if_disable_security_is_set "${FUNCNAME[0]}")"
      # disable security, learning mode, and fail fast logic is in the upstream function; if it returns non-zero we should return with that immediately
      return "${tool_return}"
    fi

    ## Only run security tools if (1) it is the first time, or (2) we are able to detect a change
    dirs_to_hash=("${dir}")
  {%- if monitor is defined %}
    {%- for env_var in monitor["env_vars"] if monitor["env_vars"] %}
    if [[ -n {{ '${' }}{{ env_var }}} ]]; then
      dirs_to_hash+=("{{ '${' }}{{ env_var }}}")
    fi
    {%- endfor %}
  {%- endif %}
    run_scans="$(should_we_run_scans "${dirs_to_hash[@]}")"

  {%- if validations is defined %}
    ## Validate the input prior to running security tooling
    {%- for validation in validations %}
    command {{ validation.command }} &>/tmp/{{ validation.command | replace(" ", "_") }}_stdouterr
    process_command_exit_status "$?" "{{ validation.command }}" "{{ validation.description }}"
    return=$?
    if [[ "${return:-1}" != 0 ]]; then
      cat /tmp/{{ validation.command | replace(" ", "_") }}_stdouterr
      if [[ "${LEARNING_MODE,,}" == "true" ]]; then
        _feedback DEBUG "Learning mode enabled, not returning {{ validation.command }}'s exit code of ${return}"
      else
        popd > /dev/null
        if [[ "${FAIL_FAST:-false}" == "true" ]]; then
          _feedback INFO "FAIL_FAST is set to ${FAIL_FAST}; returning the exit code of ${return} immediately"
          return "${return}"
        else
          command_dir_exit_codes["${dir}"]="${return}"
          continue
        fi
      fi
    fi
    {%- endfor -%}
  {%- endif %}

    ## Setup the per-tool security integrations
    {#- For each command being wrapped, loop through each security tool and apply tool-specific skips based on env vars/arguments #}
    {%- for security_tool in security_tools %}
    {{ security_tool | replace("-", "_") }}_skip_argument="--skip-{{ security_tool | replace("-", "_") }}"
    {{ security_tool | replace("-", "_") }}_upper=$(echo "{{ security_tool | replace("-", "_") }}" | tr '[:lower:]' '[:upper:]')
    {{ security_tool | replace("-", "_") }}_skip_env_var="SKIP_{{ '${' }}{{ security_tool | replace("-", "_") }}_upper}"
    declare "SKIP_{{ '${' }}{{ security_tool | replace("-", "_") }}_upper}={{ '${' }}!{{ security_tool | replace("-", "_") }}_skip_env_var:-false}"

    local should_we_run_security_tool "{{ security_tool }}" "{{ '${' }}{{ security_tool | replace("-", "_") }}_skipped:-false}"

    if [[ "${run_scans}" == "true" && "${should_we_run_security_tool}" == "true" ]]; then
      if [[ -x $(which {{ security_tool }}) ]]; then
        # TODO: run_security_tool, left off here...
        security_tool_command='{{ security_tools[security_tool].command }}'
        {%- if security_tools[security_tool]["arg_customizations"] is defined %}
        {%- for env_var, argument in security_tools[security_tool]["arg_customizations"].items() %}
        if [[ -v {{ env_var }} ]]; then
          append=' {{ argument }} "{{ '${' }}{{ env_var }}{{ '}' }}"'
          security_tool_command+="${append}"
          _feedback DEBUG "Adding '${append}' to the end of the {{ security_tool }} command"
        fi
        {%- endfor %}
        {%- endif %}
        {%- if security_tools[security_tool]["env_customizations"] is defined %}
        {%- for config_env_var, security_tool_env in security_tools[security_tool]["env_customizations"].items() %}
        if [[ -v {{ config_env_var }} ]]; then
          prefix="{{ security_tool_env }}={{ '${' }}{{ config_env_var }}{{ '}' }}"
          security_tool_command="${prefix} ${security_tool_command}"
          _feedback DEBUG "Adding '${prefix}' to the beginning of the {{ security_tool }} command"
        fi
        {%- endfor %}
        {%- endif %}
        _feedback DEBUG "Running '${security_tool_command} &>/tmp/{{ security_tool | replace("-", "_") }}_stdouterr'"
        eval "${security_tool_command} &>/tmp/{{ security_tool | replace("-", "_") }}_stdouterr"
        process_command_exit_status "$?" "{{ security_tool | replace("-", "_") }}" "{{ security_tools[security_tool].description }}"
        return=$?

        # Identify the best message content to log
        if [[ -v {{ security_tool | upper | replace("-", "_") }}_JSON_REPORT_PATH && -r "{{ '${' }}{{ security_tool | upper | replace("-", "_") }}{{ '_JSON_REPORT_PATH}' }}/{{ security_tool | replace("-", "_") }}.json" ]]; then
          message_file_path="{{ '${' }}{{ security_tool | upper | replace("-", "_") }}{{ '_JSON_REPORT_PATH}' }}/{{ security_tool | replace("-", "_") }}.json"
          message_type="json"
        else
          _feedback DEBUG "{{ security_tool | upper | replace("-", "_") }}{{ '_JSON_REPORT_PATH' }} was not set or {{ '\${' }}{{ security_tool | upper | replace("-", "_") }}{{ '_JSON_REPORT_PATH}' }}/{{ security_tool | replace("-", "_") }}.json is not readable; falling back to /tmp/{{ security_tool | replace("-", "_") }}_stdouterr"
          message_file_path="/tmp/{{ security_tool | replace("-", "_") }}_stdouterr"
          message_type="string"
        fi

        _feedback DEBUG "The message type was set to ${message_type:-null or unset}"

        # Identify the interpolated security tool command
        interpolated_security_tool_command="$(envsubst "$(printf '{{ '${' }}%s{{ '}' }} ' $(env | awk -F\= '{print $1}'))" < <(echo "${security_tool_command}"))"

        if [[ "${return:-1}" != 0 ]]; then
          cat /tmp/{{ security_tool | replace("-", "_") }}_stdouterr

          if [[ "${LEARNING_MODE,,}" == "true" ]]; then
            _log "{{ security_tool }}.stdouterr" allowed failure "${interpolated_security_tool_command}" "${dir}" "${message_type}" "${message_file_path}"
            _feedback DEBUG "{{ security_tool }} running from the ${dir} folder exited ${return}, but suppressing it due to learning mode"
          else
            _log "{{ security_tool }}.stdouterr" denied failure "${interpolated_security_tool_command}" "${dir}" "${message_type}" "${message_file_path}"
            _feedback DEBUG "{{ security_tool }} running from the ${dir} folder exited ${return}; learning mode was ${LEARNING_MODE:-null or unset}. Returning ${return}"
            popd > /dev/null
            if [[ "${FAIL_FAST:-false}" == "true" ]]; then
              _feedback INFO "FAIL_FAST is set to ${FAIL_FAST}; returning the exit code of ${return} immediately"
              return "${return}"
            else
              command_dir_exit_codes["${dir}"]="${return}"
              continue
            fi
          fi
        else
          # easy_infra allowed the command and the security tool succeeded
          _log "{{ security_tool }}.stdouterr" allowed success "${interpolated_security_tool_command}" "${dir}" "${message_type}" "${message_file_path}"
          _feedback DEBUG "{{ security_tool }} was run successfully from the ${dir} folder; specifically '${interpolated_security_tool_command}'"
        fi
      else
        # easy_infra skipped the security tool
        _log "{{ security_tool }}.stdouterr" info unknown "{{ security_tool }}" "${dir}" string "{{ security_tool }} was not run because it was either not in the path or is not executable"
        _feedback DEBUG "Did not run {{ security_tool }} because it was either not in the path or is not executable"
      fi
    fi
    {%- endfor %}

    # Run the command per a PATH lookup, after any easy_infra specific arguments are removed
    run_command "${FUNCNAME[0]}" "${arguments[@]}"
    return=$?
    if [[ "${return:-1}" != 0 ]]; then
      popd > /dev/null
      _feedback ERROR "${FUNCNAME[0]} ${arguments[@]} exited ${return} in ${dir}"
      if [[ "${FAIL_FAST:-false}" == "true" ]]; then
        _feedback INFO "FAIL_FAST is set to ${FAIL_FAST}; returning the exit code of ${return} immediately"
        return "${return}"
      else
        command_dir_exit_codes["${dir}"]="${return}"
        continue
      fi
    fi

    popd > /dev/null
  done

  ## Process the exit codes from each directory; refactor in the future if this expands to more scenarios
  something_failed="false" # process_dir_exit_codes may modify this
  pre_failure_exit_code="$(process_dir_exit_codes "pre hooks" "${pre_hook_dir_exit_codes[@]}")"
  command_failure_exit_code="$(process_dir_exit_codes "command" "${command_dir_exit_codes[@]}")"

  # Return the last exit code encountered
  if [[ "${something_failed}" == "true" ]]; then
    if [[ "${pre_failure_exit_code}" -gt 0 ]]; then
      return "${pre_failure_exit_code}"
    elif [[ "${command_failure_exit_code}" -gt 0 ]]; then
      return "${command_failure_exit_code}"
    else
      return 0
    fi
  fi
}
{% endmacro %}

{# Loop through each of the provided packages, aliases, or tool names to be wrapped and generate a function for each -#}
{% for package in packages if packages[package]["security"] -%}
{% for alias in packages[package]["aliases"] -%}
{# Create the alias function -#}
{{ function(alias, package) }}
{# And then a scan alias function -#}
{{ function(alias, package, scan=true) }}
{% else %}
{# Create the package function -#}
{{ function(package) }}
{# And then a scan package function -#}
{{ function(package, scan=true) }}
{% endfor %}
{# Add in a function for any custom tool names -#}
{% if "tool" in packages[package] and "name" in packages[package]["tool"] -%}
{{ function(packages[package]["tool"]["name"], package, scan=true) }}
{% endif %}
{%- endfor -%}
